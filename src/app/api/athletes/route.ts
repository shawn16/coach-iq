import { NextResponse } from "next/server";
// Import the prisma client using the correct relative path
import prisma from "../../../lib/prisma";
// Import the Athlete type generated by Prisma - REMOVED
// Import Prisma type for create input
import { Prisma } from "@/generated/prisma/client";
// Import the time parsing utility
import { parseTimeToMilliseconds } from "@/lib/utils";

// Disable SSL certificate validation in development only
// WARNING: This is insecure and should NEVER be used in production
// if (process.env.NODE_ENV === "development") {
//   process.env.NODE_TLS_REJECT_UNAUTHORIZED = "0";
// }

// Sample data as a fallback in case there are connection issues
// Removed sampleAthletes array

// Define a type for the selected athlete data
interface SelectedAthlete {
  id: number;
  firstName: string;
  lastName: string;
  birthday: Date;
  grade: number;
  time1600m: number | null; // Prisma Int can be null
}

export async function GET() {
  try {
    // Fetch data using Prisma
    console.log("Attempting to fetch athletes using Prisma...");
    // Note: Prisma returns Date objects for DateTime fields
    // and Int for Int fields directly.
    // Adjust field names to match Prisma schema (camelCase)
    const athletes = await prisma.athlete.findMany({
      orderBy: {
        lastName: "asc",
      },
      select: {
        id: true,
        firstName: true,
        lastName: true,
        birthday: true, // Keep as Date object
        grade: true,
        time1600m: true, // Keep as Int
      },
    });
    console.log(
      `Successfully fetched ${athletes.length} athletes using Prisma.`
    );

    // Enhance the data with projected times (same logic as before)
    // Use the specific type for the mapped data
    const enhancedData = athletes.map((athlete: SelectedAthlete) => {
      // Use nullish coalescing for potentially null time1600m
      const time1600m = athlete.time1600m ?? 0;
      return {
        id: athlete.id.toString(), // Convert id to string if needed by frontend
        first_name: athlete.firstName, // Map to snake_case if needed
        last_name: athlete.lastName, // Map to snake_case if needed
        birthday: athlete.birthday.toISOString().split("T")[0], // Format Date to YYYY-MM-DD string
        grade: athlete.grade,
        time_1600m: time1600m, // Map to snake_case if needed
        projected_5k: time1600m ? formatTimeForDisplay(time1600m * 3.1) : "-",
        projected_3200m: time1600m ? formatTimeForDisplay(time1600m * 2) : "-",
        projected_800m: time1600m ? formatTimeForDisplay(time1600m * 0.5) : "-",
      };
    });

    return NextResponse.json(enhancedData);
  } catch (error) {
    // Log the error
    console.error("Error fetching athletes using Prisma:", error);
    // Return a proper error response
    return NextResponse.json(
      { error: "Failed to fetch athletes" },
      { status: 500 }
    );
  }
}

// Helper function to format time in milliseconds to MM:SS.MS format
function formatTimeForDisplay(milliseconds: number): string {
  const totalSeconds = milliseconds / 1000;
  const minutes = Math.floor(totalSeconds / 60);
  const seconds = Math.floor(totalSeconds % 60);
  const millisecs = Math.floor((totalSeconds - Math.floor(totalSeconds)) * 100);

  return `${minutes}:${seconds.toString().padStart(2, "0")}.${millisecs
    .toString()
    .padStart(2, "0")}`;
}

// --- POST Handler ---

// Define expected request body structure
interface NewAthletePayload {
  first_name: string;
  last_name: string;
  birthday: string;
  grade: number;
  time_1600m_str: string; // Expect mandatory string
}

export async function POST(request: Request) {
  console.log("Received POST request to /api/athletes");
  try {
    const body: NewAthletePayload = await request.json();
    console.log("Request body:", body);

    // --- Temporary Hardcoded Coach ID ---
    // TODO: Replace with actual authenticated user ID from session/token
    const tempCoachId = "hardcoded-coach-cuid"; // MUST replace later
    // --- End Temporary ---

    // Basic Validation (add check for time_1600m_str)
    if (!body.first_name || !body.last_name || !body.birthday || !body.grade || !body.time_1600m_str) {
      console.log("Validation failed: Missing required fields");
      return NextResponse.json(
        { error: "Missing required fields" },
        { status: 400 }
      );
    }

    // Parse and validate birthday (keep as is)
    const birthdayDate = new Date(body.birthday);
    if (isNaN(birthdayDate.getTime())) {
      console.log("Validation failed: Invalid birthday format");
      return NextResponse.json(
        { error: "Invalid birthday format" },
        { status: 400 }
      );
    }

    // Parse and validate 1600m time string
    const time1600mMs = parseTimeToMilliseconds(body.time_1600m_str);
    if (time1600mMs === null) {
        console.log("Validation failed: Invalid 1600m time format");
        return NextResponse.json(
            { error: "Invalid 1600m time format provided." },
            { status: 400 }
        );
    }

    // Prepare data for Prisma - time1600m is now mandatory number
    const prismaData: Prisma.AthleteCreateInput = {
      firstName: body.first_name,
      lastName: body.last_name,
      birthday: birthdayDate,
      grade: body.grade,
      time1600m: time1600mMs, // Assign parsed milliseconds directly
      coach: {
        connect: { id: tempCoachId }
      },
    };

    console.log("Attempting to create athlete with data:", prismaData);

    // Create athlete in the database
    const newAthlete = await prisma.athlete.create({
      data: prismaData,
    });

    console.log("Successfully created athlete:", newAthlete);

    // Return the newly created athlete
    return NextResponse.json(newAthlete, { status: 201 }); // 201 Created

  } catch (error: unknown) { // Use unknown type
    console.error("Error creating athlete:", error);

    if (error instanceof SyntaxError) {
      return NextResponse.json({ error: "Invalid JSON payload" }, { status: 400 });
    }

    let errorMessage = "Failed to create athlete";
    if (typeof error === 'object' && error !== null) {
      if ('message' in error && typeof error.message === 'string') {
        // Check for Prisma error code within the message or specific structure if known
        // For now, just use the message
        errorMessage = `Database error: ${error.message}`;
      } else if (error instanceof Error) {
        errorMessage = `Server error: ${error.message}`;
      }
    } // else: Keep default generic error message

    return NextResponse.json(
      { error: errorMessage },
      { status: 500 }
    );
  }
}
